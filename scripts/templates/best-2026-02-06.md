## Additional Best Practices for .mjs, ES6+, Vitest & Playwright (Appended {{APPEND_DATE}})

Please refer to roo-code memory-bank instructions for more information.

- **.mjs / ESM style**
  - Use the `.mjs` extension for module files and always use ESM syntax (`import` / `export`); avoid `require()`.
  - Prefer named exports for clarity; use a single default export only where it simplifies the module's public API.
  - Use top-level `await` only when necessary and safe for consumers; modules are strict by default—no explicit "use strict" needed.
  - Keep module side-effects explicit and documented; avoid hidden global state.

- **ES6+ patterns**
  - Prefer `const` for immutable bindings and `let` for reassignable variables; avoid `var`.
  - Use arrow functions for concise callbacks and function expressions; prefer function declarations where hoisting or clarity is required.
  - Use object/array destructuring to improve readability and reduce noise.
  - Favor template literals for complex string construction and the spread/rest operators for argument/array handling.
  - Keep modules small and focused; prefer composition over large utility files.

- **Vitest best practices**
  - Organize tests with `describe`/`it` (or `test`) blocks; use `beforeEach`/`afterEach` for repeatable setup/teardown.
  - Name tests descriptively (e.g., "should handle ED prefix fallback correctly").
  - Use explicit matchers (`toBe`, `toEqual`, `toStrictEqual`, `toHaveLength`, etc.) and prefer `toStrictEqual` for deep structural assertions when appropriate.
  - Mock only what is necessary and scope mocks to the smallest possible area; prefer dependency injection where practical.
  - Use `it.each` for data-driven cases and keep tests isolated to avoid order dependencies.
  - Aim for clear coverage goals and add unit tests for low-coverage critical files (e.g., `z80.mjs`, `ula.mjs`, `memory.mjs`).
  - When proposing logic changes, include a **"Tests to add"** section with file name, brief description, and expected failing assertion.

- **Playwright E2E best practices**
  - Use `page.locator()` over raw selectors; prefer robust, semantic locators to reduce flakiness.
  - Always `await` actions and assertions (e.g., `await expect(locator).toBeVisible()`, `await expect(locator).toHaveText()`).
  - Use `test.describe` and fixtures for shared setup; capture traces and screenshots on failure to aid debugging.
  - Create a small, fast `@smoke` subset for pre-commit verification and broader `@regression` suites for CI.
  - Tag tests with `@smoke` / `@regression` and use `--grep` to run targeted subsets in CI and locally.

- **General code quality reminders**
  - Favor small, pure functions with clear inputs and outputs; minimize side-effects and global state.
  - Avoid magic numbers—extract named constants and document their meaning.
  - Use `===` / `!==` for comparisons and consistent naming conventions across the codebase.
  - Keep tests deterministic and independent; avoid network or file-system side effects in unit tests (use mocks/fakes instead).
  - Keep commits small, focused, and accompanied by relevant tests and a short changelog message.

- **Verification reminder**
  - Always verify with: `npm run test:unit && npx playwright test tests/e2e --grep @smoke`
